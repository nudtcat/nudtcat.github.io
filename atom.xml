<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>喜欢冒险探索的程序猿</title>
  <subtitle>喜欢冒险探索的程序猿</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.nudtcat.org/"/>
  <updated>2016-09-24T03:34:08.000Z</updated>
  <id>http://blog.nudtcat.org/</id>
  
  <author>
    <name>nudtcat</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一个简单的爬虫</title>
    <link href="http://blog.nudtcat.org/default/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%88%AC%E8%99%AB/"/>
    <id>http://blog.nudtcat.org/default/一个简单的爬虫/</id>
    <published>2016-09-24T03:31:03.000Z</published>
    <updated>2016-09-24T03:34:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-初衷"><a href="#0x01-初衷" class="headerlink" title="0x01 初衷"></a>0x01 初衷</h2><p>最近准备开始写一些通用的自动化工具，以前也写过一些自动化的东西，不过都是用胶水把一些现成的工具粘连起来而已。自己开始写工具并不只是造轮子，我希望把尽自己最大的努力，每一个模块都做到最细致，规则做到最好，所以这个project会持续很长的时间，而且有可能会重构很多次。<br><a id="more"></a></p>
<h2 id="0x02-设计"><a href="#0x02-设计" class="headerlink" title="0x02 设计"></a>0x02 设计</h2><p>这个爬虫的作用是从一个网页作为开始，爬取相关联的网页。需要注意的有几个点，一是从html中获取链接，使用有很多种方法都可以形成链接的效果，获取链接同样有很多解决方案。二是多线程问题，可以使用简单的线程池，重点在于多线程下的同步和互斥的问题。我在<a href="http://blog.nudtcat.org/default/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98%E7%9A%84Python%E5%AE%9E%E7%8E%B0/">生产者消费者问题的Python实现</a>中说到过，其实链接队列就是这个模型，解析模块不停生产链接，插入queue，request模块不停从queue中获取链接，然后将html交给解析模块。解决方法可以看这篇文章。三是链接去重问题，最差的时间复杂度是O(n)，如果链接不多，内存足够，时间复杂度可以到O(1)，但是怎么在大数量级的情况下快速判断一个链接是否重复，是一个难题，但是也有现成的解决方案。另一个问题是具体的规则，同一个页面，不同的锚点可以被优化为只爬取一次。</p>
<p>以上的三个问题，每个问题都可以作为单独一个project深入研究下去，但是那就是software engineer的范畴了。</p>
<h2 id="0x03-简单的设计"><a href="#0x03-简单的设计" class="headerlink" title="0x03 简单的设计"></a>0x03 简单的设计</h2><p>我不喜欢啥都不说，虽然talk is cheap，show me the code。但是把要点说出来，更容易让初学者把握。我写了一个简单的实现，见<a href="https://github.com/nudtcat/simple_crawler/" target="_blank" rel="external">我的github</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x01-初衷&quot;&gt;&lt;a href=&quot;#0x01-初衷&quot; class=&quot;headerlink&quot; title=&quot;0x01 初衷&quot;&gt;&lt;/a&gt;0x01 初衷&lt;/h2&gt;&lt;p&gt;最近准备开始写一些通用的自动化工具，以前也写过一些自动化的东西，不过都是用胶水把一些现成的工具粘连起来而已。自己开始写工具并不只是造轮子，我希望把尽自己最大的努力，每一个模块都做到最细致，规则做到最好，所以这个project会持续很长的时间，而且有可能会重构很多次。&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>生产者消费者问题的Python实现</title>
    <link href="http://blog.nudtcat.org/default/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98%E7%9A%84Python%E5%AE%9E%E7%8E%B0/"/>
    <id>http://blog.nudtcat.org/default/生产者消费者问题的Python实现/</id>
    <published>2016-09-24T03:13:48.000Z</published>
    <updated>2016-09-24T03:34:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-背景知识"><a href="#0x00-背景知识" class="headerlink" title="0x00 背景知识"></a>0x00 背景知识</h2><p>生产者和消费者是一个常见的问题，它的模型是多个生产者在生产产品，同时多个消费者消费产品，但是仓库容量是有限的，所以当仓库满了生产者需要休眠，而当仓库空了消费者需要唤醒生产者。这里面涉及的问题有互斥和同步。</p>
<h2 id="0x01-一种解决方法"><a href="#0x01-一种解决方法" class="headerlink" title="0x01 一种解决方法"></a>0x01 一种解决方法</h2><p>可以使用锁来负责互斥，使用threading.Condition来做同步。threading的完整用法见<a href="https://docs.python.org/2/library/threading.html" target="_blank" rel="external">官方文档</a>，Condition的完整用法见<a href="https://docs.python.org/2/library/threading.html#condition-objects" target="_blank" rel="external">Condition的描述</a>。简单来说，Condition内置了锁，当调用acquire()方法时，自动上锁，release()释放锁。wait()方法会释放锁后阻塞程序，直到被notify()方法唤醒。Talk is cheap, this is the code.<br><a id="more"></a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> threading</div><div class="line"><span class="keyword">import</span> random</div><div class="line"><span class="keyword">import</span> time</div><div class="line"></div><div class="line">warehouse = []</div><div class="line">max_num = <span class="number">10</span></div><div class="line">condition = threading.Condition()</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProducerThread</span><span class="params">(threading.Thread)</span>:</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">		threading.Thread.__init__(self)</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line">		<span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">			condition.acquire()</div><div class="line">			<span class="keyword">if</span> len(warehouse) == max_num:</div><div class="line">				<span class="keyword">print</span> <span class="string">"Warehouse is full"</span></div><div class="line">				condition.wait()  <span class="comment"># Release the lock</span></div><div class="line">				<span class="keyword">print</span> <span class="string">"Producer is notified by consumer"</span></div><div class="line">			<span class="keyword">else</span>:</div><div class="line">				warehouse.append(<span class="number">1</span>)</div><div class="line">				<span class="keyword">print</span> <span class="string">"Producer is working, NUM: "</span> + str(len(warehouse))</div><div class="line">			condition.notify()</div><div class="line">			condition.release()</div><div class="line">			time.sleep(random.random())</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConsumerThread</span><span class="params">(threading.Thread)</span>:</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">		threading.Thread.__init__(self)</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line">		<span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">			condition.acquire()</div><div class="line">			<span class="keyword">if</span> len(warehouse) == <span class="number">0</span>:</div><div class="line">				<span class="keyword">print</span> <span class="string">"Warehouse is empty"</span></div><div class="line">				condition.wait()</div><div class="line">				<span class="keyword">print</span> <span class="string">"Consumer is notified by producer"</span></div><div class="line">			<span class="keyword">else</span>:</div><div class="line">				warehouse.pop()</div><div class="line">				<span class="keyword">print</span> <span class="string">"Consumer is working, NUM: "</span> + str(len(warehouse))</div><div class="line">			condition.notify()</div><div class="line">			condition.release()</div><div class="line">			time.sleep(random.random())</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">	c_list = []</div><div class="line">	p_list = []</div><div class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</div><div class="line">		p = ProducerThread()</div><div class="line">		p_list.append(p)</div><div class="line">		p.start()</div><div class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>):</div><div class="line">		c = ConsumerThread()</div><div class="line">		c_list.append(c)</div><div class="line">		c.start()</div></pre></td></tr></table></figure></p>
<p>常见的错误❌代码如下，这是来自网上关于这个知识点的示例，真是天下代码一大抄啊。至于错误原因，读者不难发现。下面的代码会超过仓库的最大存储。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, Condition</div><div class="line"><span class="keyword">import</span> time</div><div class="line"><span class="keyword">import</span> random</div><div class="line"></div><div class="line">queue = []</div><div class="line">MAX_NUM = <span class="number">10</span></div><div class="line">condition = Condition()</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProducerThread</span><span class="params">(Thread)</span>:</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line">		nums = range(<span class="number">5</span>)</div><div class="line">		<span class="keyword">global</span> queue</div><div class="line">		<span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">			condition.acquire()</div><div class="line">			<span class="keyword">if</span> len(queue) == MAX_NUM:</div><div class="line">				<span class="keyword">print</span> <span class="string">"Queue full, producer is waiting"</span></div><div class="line">				condition.wait()</div><div class="line">				<span class="keyword">print</span> <span class="string">"Space in queue, Consumer notified the producer"</span></div><div class="line">			num = random.choice(nums)</div><div class="line">			queue.append(num)</div><div class="line">			<span class="keyword">print</span> <span class="string">"Produced"</span>, len(queue)</div><div class="line">			condition.notify()</div><div class="line">			condition.release()</div><div class="line">			time.sleep(random.random())</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConsumerThread</span><span class="params">(Thread)</span>:</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line">		<span class="keyword">global</span> queue</div><div class="line">		<span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">			condition.acquire()</div><div class="line">			<span class="keyword">if</span> <span class="keyword">not</span> queue:</div><div class="line">				<span class="keyword">print</span> <span class="string">"Nothing in queue, consumer is waiting"</span></div><div class="line">				condition.wait()</div><div class="line">				<span class="keyword">print</span> <span class="string">"Producer added something to queue and notified the consumer"</span></div><div class="line">			num = queue.pop(<span class="number">0</span>)</div><div class="line">			<span class="keyword">print</span> <span class="string">"Consumed"</span>, len(queue)</div><div class="line">			condition.notify()</div><div class="line">			condition.release()</div><div class="line">			time.sleep(random.random())</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">	c_list = []</div><div class="line">	p_list = []</div><div class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</div><div class="line">		p = ProducerThread()</div><div class="line">		p_list.append(p)</div><div class="line">		p.start()</div><div class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</div><div class="line">		c = ConsumerThread()</div><div class="line">		c_list.append(c)</div><div class="line">		c.start()</div></pre></td></tr></table></figure></p>
<h2 id="0x02-基于Queue的实现"><a href="#0x02-基于Queue的实现" class="headerlink" title="0x02 基于Queue的实现"></a>0x02 基于Queue的实现</h2><p>Queue模块内置了Condition，可以使用Queue同时满足互斥和同步两个要求。Queue本来就是线程安全的，而Queue的task_done()方法可以用来同步。Queue的详细使用见<a href="https://docs.python.org/2/library/queue.html" target="_blank" rel="external">官方文档</a>。这个实现代码如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> Queue</div><div class="line"><span class="keyword">import</span> threading</div><div class="line"><span class="keyword">import</span> time</div><div class="line"><span class="keyword">import</span> random</div><div class="line"></div><div class="line">product_queue = Queue.Queue(<span class="number">10</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProducerThread</span><span class="params">(threading.Thread)</span>:</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">		threading.Thread.__init__(self)</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line">		<span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">			product_queue.put(<span class="number">1</span>, block=<span class="keyword">True</span>)</div><div class="line">			time.sleep(random.random())</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConsumerThread</span><span class="params">(threading.Thread)</span>:</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">		threading.Thread.__init__(self)</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line">		<span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">			product_queue.get(block=<span class="keyword">True</span>)</div><div class="line">			product_queue.task_done()</div><div class="line">			time.sleep(random.random())</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">	c_list = []</div><div class="line">	p_list = []</div><div class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</div><div class="line">		p = ProducerThread()</div><div class="line">		p_list.append(p)</div><div class="line">		p.start()</div><div class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</div><div class="line">		c = ConsumerThread()</div><div class="line">		c_list.append(c)</div><div class="line">		c.start()</div></pre></td></tr></table></figure></p>
<p>Queue也是用Condition来实现的，注意:</p>
<blockquote>
<p>Note: the notify() and notifyAll() methods don’t release the lock; this means that the thread or threads awakened will not return from their wait() call immediately, but only when the thread that called notify() or notifyAll() finally relinquishes ownership of the lock.</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x00-背景知识&quot;&gt;&lt;a href=&quot;#0x00-背景知识&quot; class=&quot;headerlink&quot; title=&quot;0x00 背景知识&quot;&gt;&lt;/a&gt;0x00 背景知识&lt;/h2&gt;&lt;p&gt;生产者和消费者是一个常见的问题，它的模型是多个生产者在生产产品，同时多个消费者消费产品，但是仓库容量是有限的，所以当仓库满了生产者需要休眠，而当仓库空了消费者需要唤醒生产者。这里面涉及的问题有互斥和同步。&lt;/p&gt;
&lt;h2 id=&quot;0x01-一种解决方法&quot;&gt;&lt;a href=&quot;#0x01-一种解决方法&quot; class=&quot;headerlink&quot; title=&quot;0x01 一种解决方法&quot;&gt;&lt;/a&gt;0x01 一种解决方法&lt;/h2&gt;&lt;p&gt;可以使用锁来负责互斥，使用threading.Condition来做同步。threading的完整用法见&lt;a href=&quot;https://docs.python.org/2/library/threading.html&quot;&gt;官方文档&lt;/a&gt;，Condition的完整用法见&lt;a href=&quot;https://docs.python.org/2/library/threading.html#condition-objects&quot;&gt;Condition的描述&lt;/a&gt;。简单来说，Condition内置了锁，当调用acquire()方法时，自动上锁，release()释放锁。wait()方法会释放锁后阻塞程序，直到被notify()方法唤醒。Talk is cheap, this is the code.&lt;br&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://blog.nudtcat.org/tags/Python/"/>
    
      <category term="操作系统" scheme="http://blog.nudtcat.org/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>珍惜大学仅剩的一年</title>
    <link href="http://blog.nudtcat.org/default/%E7%8F%8D%E6%83%9C%E5%A4%A7%E5%AD%A6%E4%BB%85%E5%89%A9%E7%9A%84%E4%B8%80%E5%B9%B4/"/>
    <id>http://blog.nudtcat.org/default/珍惜大学仅剩的一年/</id>
    <published>2016-09-23T14:15:59.000Z</published>
    <updated>2016-09-24T03:34:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>珍惜最后一年的大学生活</p>
<ul>
<li>写一篇优秀的毕业论文</li>
<li>在大雨天跑一次步</li>
<li>感受教学楼，图书馆，读几本书</li>
<li>毕业旅行</li>
<li>来一次冒险(骑行||徒步)<a id="more"></a>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;珍惜最后一年的大学生活&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;写一篇优秀的毕业论文&lt;/li&gt;
&lt;li&gt;在大雨天跑一次步&lt;/li&gt;
&lt;li&gt;感受教学楼，图书馆，读几本书&lt;/li&gt;
&lt;li&gt;毕业旅行&lt;/li&gt;
&lt;li&gt;来一次冒险(骑行||徒步)
    
    </summary>
    
    
      <category term="大学生活" scheme="http://blog.nudtcat.org/tags/%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
</feed>
