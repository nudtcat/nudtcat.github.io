<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>喜欢冒险探索的程序猿</title>
  <subtitle>喜欢冒险探索的程序猿</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.nudtcat.org/"/>
  <updated>2016-09-24T11:29:52.000Z</updated>
  <id>http://blog.nudtcat.org/</id>
  
  <author>
    <name>nudtcat</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>宽字节注入问题</title>
    <link href="http://blog.nudtcat.org/default/%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A5%E9%97%AE%E9%A2%98/"/>
    <id>http://blog.nudtcat.org/default/宽字节注入问题/</id>
    <published>2016-09-25T01:23:19.000Z</published>
    <updated>2016-09-24T11:29:52.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-宽字节"><a href="#0x00-宽字节" class="headerlink" title="0x00 宽字节"></a>0x00 宽字节</h2><p>在代码注入攻击中，宽字节问题已经是老生常谈。注意，这里的代码注入是指宽泛的代码注入：<strong>所有突破数据与代码边界，使数据注入代码段，变成可执行代码</strong>的攻击手法都可以叫代码注入，包括SQL注入和XSS。啥是宽字节呢？其实就是用多个字节表示一个字符。<br><a id="more"></a></p>
<h2 id="0x01-另一个角度看MySQL的宽字节注入问题"><a href="#0x01-另一个角度看MySQL的宽字节注入问题" class="headerlink" title="0x01 另一个角度看MySQL的宽字节注入问题"></a>0x01 另一个角度看MySQL的宽字节注入问题</h2><p>先说说MySQL中的宽字节注入，MySQL在接受到php传来的SQL语句时，会使用MySQL设置中的character_set_client设置值进行编码。而如果character_set_client是一个宽字符集，那么可能会将SQL语句中的多个字节编码成一个字符，这样就改变了SQL语句的原意。我们对这个编码前的SQL语句稍加控制，使编码编掉一些字符，比如\，这样就能绕过php层的安全策略。说起来可能略抽象，下面打一个简单的比方。</p>
<p>实验环境：magic_quotes_gpc=Off，php代码如下<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">$a=$_GET[<span class="string">'a'</span>];</div><div class="line">$a=addslashes($a);</div><div class="line"><span class="keyword">print</span> <span class="string">"select * from admin where name='"</span>.$a.<span class="string">"'"</span>;</div></pre></td></tr></table></figure></p>
<p>代码非常简单，将传入的a使用addslashes函数转义，转义掉单引号等字符。我们请求<a href="http://115.28.188.93/1.php?a=admin%df" target="_blank" rel="external">http://115.28.188.93/1.php?a=admin%df</a>‘ and 1=1 – s抓包，看到的响应如下图<br><img src="/images/0924_01.png" alt=""><br>红色框中被选中的内容就是响应的内容，这个是二进制的，可以看做是SQL语句在传给MySQL的时候的状态。这个时候，浏览器的返回时这样的(浏览器编码设置为UTF-8)<br><img src="/images/0924_02.png" alt=""></p>
<p>在这里，浏览器设置的编码相当于MySQL的character_set_client，浏览器会对http响应的部分做编码，MySQL也是一样，这种情况下，我们发现我们请求中的单引号已经被转义了，无法形成SQL注入。我们把浏览器编码设置为gbk，再看看<br><img src="/images/0924_03.png" alt=""></p>
<p>这个时候，我们发现\不见了，我们插入的单引号成功闭合了前面的单引号，and 1=1已经插入到了SQL语句代码部分，能影响SQL语句的逻辑。也就是说，这个时候，我们相当于把MySQL的character_set_client设置成了gbk，成功引发了宽字节的注入问题，这就是整个数据流的流向，最复杂的一部分已经弄清楚了，下面就是一些细节问题了。</p>
<p>在admin%df’被addslashes后，结果是admin%df\’,也就是admin%df%5c%27,而将其转换为gbk编码后，%df%5c代表一个中文字符，然后就被编码成運，喜闻乐见的，我们的单引号就被插入了。</p>
<p>(题外话：不同浏览器在得到一个没有指定编码的html响应时可能会采用不同的编码，我的Chrome和Firefox就是这样。所以，请手动设置编码方式)</p>
<p>哪些范围会被gbk编码成汉字呢？根据gbk编码，第一个字节ascii码大于128，基本上就可以了。如果character_set_client是gb2312，能不能成功呢？理论上来说，只要\，也就是%5c在某些字符集的低位中，都是可以的，不巧，gb2312的低位范围是0xA1~0xFE，所以不可以。</p>
<h2 id="0x03-初衷"><a href="#0x03-初衷" class="headerlink" title="0x03 初衷"></a>0x03 初衷</h2><p>我为啥写这篇文章？phithon在Freebuf上的<a href="http://www.freebuf.com/articles/web/31537.html" target="_blank" rel="external">浅析白盒审计中的字符编码及SQL注入</a>写得非常好，但是我认为在SQL语句的流向方面写得不够详细，我做了一点补充，其余内容请参看phithon大神的文章。如果有什么不明白，那多半是SQL语句的流向以及编码状态不明白，可以参考我上面浏览器编码的比喻。</p>
<h2 id="0x04-意识"><a href="#0x04-意识" class="headerlink" title="0x04 意识"></a>0x04 意识</h2><p>玩儿英雄联盟的人都知道，意识最为重要。做安全也是如此，意识本质上是安全观。宽字节的问题，有可能改头换面出现在另一个地方，就看下次遇到的时候，谁能思考得深，看到更内在的东西了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x00-宽字节&quot;&gt;&lt;a href=&quot;#0x00-宽字节&quot; class=&quot;headerlink&quot; title=&quot;0x00 宽字节&quot;&gt;&lt;/a&gt;0x00 宽字节&lt;/h2&gt;&lt;p&gt;在代码注入攻击中，宽字节问题已经是老生常谈。注意，这里的代码注入是指宽泛的代码注入：&lt;strong&gt;所有突破数据与代码边界，使数据注入代码段，变成可执行代码&lt;/strong&gt;的攻击手法都可以叫代码注入，包括SQL注入和XSS。啥是宽字节呢？其实就是用多个字节表示一个字符。&lt;br&gt;
    
    </summary>
    
    
      <category term="SQL注入" scheme="http://blog.nudtcat.org/tags/SQL%E6%B3%A8%E5%85%A5/"/>
    
      <category term="宽字节" scheme="http://blog.nudtcat.org/tags/%E5%AE%BD%E5%AD%97%E8%8A%82/"/>
    
      <category term="Web安全" scheme="http://blog.nudtcat.org/tags/Web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Python装饰器</title>
    <link href="http://blog.nudtcat.org/default/Python%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    <id>http://blog.nudtcat.org/default/Python装饰器/</id>
    <published>2016-09-24T03:36:54.000Z</published>
    <updated>2016-09-24T03:41:08.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-语法糖"><a href="#0x00-语法糖" class="headerlink" title="0x00 语法糖"></a>0x00 语法糖</h2><p>装饰器是Python一个语法糖，装饰器就是在不改变原函数的基础上，在原函数前后执行一些代码，就好像在原函数上增加了一些装饰品一样。这个语法能非常方便给一个函数增加一些功能，例如权限控制，校验一个函数的输入等。<br><a id="more"></a></p>
<h2 id="0x01-语法原理"><a href="#0x01-语法原理" class="headerlink" title="0x01 语法原理"></a>0x01 语法原理</h2><h3 id="最简单的情况"><a href="#最简单的情况" class="headerlink" title="最简单的情况"></a>最简单的情况</h3><p>装饰一个有参数的函数<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span><span class="params">(func)</span>:</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args,**kwargs)</span>:</span></div><div class="line">		res=func(*args,**kwargs)</div><div class="line">		<span class="keyword">print</span> <span class="string">"function "</span>+func.__name__+<span class="string">" return "</span>+str(res)</div><div class="line">		<span class="keyword">return</span> res</div><div class="line">	<span class="keyword">return</span> wrapper</div><div class="line"></div><div class="line"><span class="meta">@debug</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">(a, b)</span>:</span></div><div class="line">	<span class="keyword">return</span> a + b</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</div><div class="line">	<span class="keyword">print</span> sum(<span class="number">1</span>,<span class="number">3</span>)</div></pre></td></tr></table></figure></p>
<p>运行结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">function sum return 4</div><div class="line">4</div></pre></td></tr></table></figure></p>
<p>这里展示了装饰器最基本的使用，给sum函数添加了debug这个装饰，这个装饰器在sum函数调用之后输出了函数名和返回值方便调试。我们看一下这个语法糖的真面目。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span><span class="params">(func)</span>:</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args,**kwargs)</span>:</span></div><div class="line">		res=func(*args,**kwargs)</div><div class="line">		<span class="keyword">print</span> <span class="string">"function "</span>+func.__name__+<span class="string">" return "</span>+str(res)</div><div class="line">		<span class="keyword">return</span> res</div><div class="line">	<span class="keyword">return</span> wrapper</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">(a, b)</span>:</span></div><div class="line">	<span class="keyword">return</span> a + b</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</div><div class="line">	<span class="keyword">print</span> debug(sum)(<span class="number">1</span>,<span class="number">3</span>)</div><div class="line">	<span class="keyword">print</span> <span class="string">"==== function ===="</span></div><div class="line">	<span class="keyword">print</span> debug</div><div class="line">	<span class="keyword">print</span> debug(sum)</div></pre></td></tr></table></figure></p>
<p>运行结果为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function sum return 4</div><div class="line">4</div><div class="line">==== function ====</div><div class="line">&lt;function debug at 0x1044c0de8&gt;</div><div class="line">&lt;function wrapper at 0x1044c0ed8&gt;</div></pre></td></tr></table></figure></p>
<p>在有装饰器的时候，调用sum(1,3)相当于调用了debug(sum)(1,3)。我们来分析一下debug(sum)(1,3)这个调用。在Python中，万物皆对象，类是一个对象，方法也是一个对象。例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">(a, b)</span>:</span></div><div class="line">	<span class="keyword">return</span> a + b</div></pre></td></tr></table></figure></p>
<p>定义了一个sum方法，同时，sum也是一个对象，它的类型是函数。sum的值是一个入口在某地址的函数。sum(1,2)就是对这个函数的调用。我们回到debug(sum)(1,3)这个函数调用，首先调用了debug这个函数，它的参数是一个函数，我们根据<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span><span class="params">(func)</span>:</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args,**kwargs)</span>:</span></div><div class="line">		res=func(*args,**kwargs)</div><div class="line">		<span class="keyword">print</span> <span class="string">"function "</span>+func.__name__+<span class="string">" return "</span>+str(res)</div><div class="line">		<span class="keyword">return</span> res</div><div class="line">	<span class="keyword">return</span> wrapper</div></pre></td></tr></table></figure></p>
<p>return wrapper表示这个函数的返回值是一个函数，即debug(sum)(1,3)相当于wrapper(1,3)。wrapper(1,3)即对wrapper函数的调用。这样，把装饰器函数的定义和语法糖背后的代码结合理解，很容易理解装饰器这个概念和@debug这样的语法。</p>
<h3 id="带参数的情况"><a href="#带参数的情况" class="headerlink" title="带参数的情况"></a>带参数的情况</h3><p>装饰器也可以带参数，这里可能比上面稍微复杂一点，如果上面的还有一点疑惑，多看两遍，在看接下来的。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">is_debug=<span class="keyword">True</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span><span class="params">(is_debug)</span>:</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(func)</span>:</span></div><div class="line">		<span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">(*args,**kwargs)</span>:</span></div><div class="line">			res=func(*args,**kwargs)</div><div class="line">			<span class="keyword">if</span>(is_debug):</div><div class="line">				<span class="keyword">print</span> <span class="string">"function "</span> + func.__name__ + <span class="string">" return "</span> + str(res)</div><div class="line">			<span class="keyword">return</span> res</div><div class="line">		<span class="keyword">return</span> inner</div><div class="line">	<span class="keyword">return</span> wrapper</div><div class="line"></div><div class="line"><span class="meta">@debug(is_debug)</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">(a, b)</span>:</span></div><div class="line">	<span class="keyword">return</span> a + b</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</div><div class="line">	<span class="keyword">print</span> sum(<span class="number">1</span>,<span class="number">3</span>)</div></pre></td></tr></table></figure></p>
<p>在这里，我们定义了一个全局变量is_debug来控制是否输出debug信息，这个值是装饰器的参数。感觉在装饰器定义多层函数，还有不同的参数，完全分不清啊有木有!<br>我们来看与上面等价的调用<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">is_debug=<span class="keyword">True</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span><span class="params">(is_debug)</span>:</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(func)</span>:</span></div><div class="line">		<span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">(*args,**kwargs)</span>:</span></div><div class="line">			res=func(*args,**kwargs)</div><div class="line">			<span class="keyword">if</span>(is_debug):</div><div class="line">				<span class="keyword">print</span> <span class="string">"function "</span> + func.__name__ + <span class="string">" return "</span> + str(res)</div><div class="line">			<span class="keyword">return</span> res</div><div class="line">		<span class="keyword">return</span> inner</div><div class="line">	<span class="keyword">return</span> wrapper</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">(a, b)</span>:</span></div><div class="line">	<span class="keyword">return</span> a + b</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</div><div class="line">	<span class="keyword">print</span> debug(is_debug)(sum)(<span class="number">1</span>,<span class="number">3</span>)</div><div class="line">	<span class="keyword">print</span> <span class="string">"==== function ===="</span></div><div class="line">	<span class="keyword">print</span> debug</div><div class="line">	<span class="keyword">print</span> debug(is_debug)</div><div class="line">	<span class="keyword">print</span> debug(is_debug)(sum)</div></pre></td></tr></table></figure></p>
<p>下面是运行结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function sum return 4</div><div class="line">4</div><div class="line">==== function ====</div><div class="line">&lt;function debug at 0x10b079e60&gt;</div><div class="line">&lt;function wrapper at 0x10b079f50&gt;</div><div class="line">&lt;function inner at 0x10b08e050&gt;</div></pre></td></tr></table></figure></p>
<p>其实，看懂这个调用的方法跟上面是一样的。不再赘述，值得一提的是这里，其实debug(is_debug)返回的这个函数可以认为是另一个没有参数的装饰器，然后整个结构就上面没有参数的情况一样了。这个新的装饰器的参数是函数，即debug(is_debug)(sum)，然后返回一个参数是<em>args,*</em>kwargs的函数，再调用这个函数，参数为1，3。即完成整个调用。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x00-语法糖&quot;&gt;&lt;a href=&quot;#0x00-语法糖&quot; class=&quot;headerlink&quot; title=&quot;0x00 语法糖&quot;&gt;&lt;/a&gt;0x00 语法糖&lt;/h2&gt;&lt;p&gt;装饰器是Python一个语法糖，装饰器就是在不改变原函数的基础上，在原函数前后执行一些代码，就好像在原函数上增加了一些装饰品一样。这个语法能非常方便给一个函数增加一些功能，例如权限控制，校验一个函数的输入等。&lt;br&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://blog.nudtcat.org/tags/Python/"/>
    
      <category term="装饰器" scheme="http://blog.nudtcat.org/tags/%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>一个简单的爬虫</title>
    <link href="http://blog.nudtcat.org/default/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%88%AC%E8%99%AB/"/>
    <id>http://blog.nudtcat.org/default/一个简单的爬虫/</id>
    <published>2016-09-24T03:31:03.000Z</published>
    <updated>2016-09-24T03:37:25.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-初衷"><a href="#0x01-初衷" class="headerlink" title="0x01 初衷"></a>0x01 初衷</h2><p>最近准备开始写一些通用的自动化工具，以前也写过一些自动化的东西，不过都是用胶水把一些现成的工具粘连起来而已。自己开始写工具并不只是造轮子，我希望把尽自己最大的努力，每一个模块都做到最细致，规则做到最好，所以这个project会持续很长的时间，而且有可能会重构很多次。<br><a id="more"></a></p>
<h2 id="0x02-设计"><a href="#0x02-设计" class="headerlink" title="0x02 设计"></a>0x02 设计</h2><p>这个爬虫的作用是从一个网页作为开始，爬取相关联的网页。需要注意的有几个点，一是从html中获取链接，使用有很多种方法都可以形成链接的效果，获取链接同样有很多解决方案。二是多线程问题，可以使用简单的线程池，重点在于多线程下的同步和互斥的问题。我在<a href="http://blog.nudtcat.org/default/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98%E7%9A%84Python%E5%AE%9E%E7%8E%B0/">生产者消费者问题的Python实现</a>中说到过，其实链接队列就是这个模型，解析模块不停生产链接，插入queue，request模块不停从queue中获取链接，然后将html交给解析模块。解决方法可以看这篇文章。三是链接去重问题，最差的时间复杂度是O(n)，如果链接不多，内存足够，时间复杂度可以到O(1)，但是怎么在大数量级的情况下快速判断一个链接是否重复，是一个难题，但是也有现成的解决方案。另一个问题是具体的规则，同一个页面，不同的锚点可以被优化为只爬取一次。</p>
<p>以上的三个问题，每个问题都可以作为单独一个project深入研究下去，但是那就是software engineer的范畴了。</p>
<h2 id="0x03-简单的设计"><a href="#0x03-简单的设计" class="headerlink" title="0x03 简单的设计"></a>0x03 简单的设计</h2><p>我不喜欢啥都不说，虽然talk is cheap，show me the code。但是把要点说出来，更容易让初学者把握。我写了一个简单的实现，见<a href="https://github.com/nudtcat/simple_crawler/" target="_blank" rel="external">我的github</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x01-初衷&quot;&gt;&lt;a href=&quot;#0x01-初衷&quot; class=&quot;headerlink&quot; title=&quot;0x01 初衷&quot;&gt;&lt;/a&gt;0x01 初衷&lt;/h2&gt;&lt;p&gt;最近准备开始写一些通用的自动化工具，以前也写过一些自动化的东西，不过都是用胶水把一些现成的工具粘连起来而已。自己开始写工具并不只是造轮子，我希望把尽自己最大的努力，每一个模块都做到最细致，规则做到最好，所以这个project会持续很长的时间，而且有可能会重构很多次。&lt;br&gt;
    
    </summary>
    
    
      <category term="爬虫" scheme="http://blog.nudtcat.org/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>生产者消费者问题的Python实现</title>
    <link href="http://blog.nudtcat.org/default/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98%E7%9A%84Python%E5%AE%9E%E7%8E%B0/"/>
    <id>http://blog.nudtcat.org/default/生产者消费者问题的Python实现/</id>
    <published>2016-09-24T03:13:48.000Z</published>
    <updated>2016-09-24T03:34:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-背景知识"><a href="#0x00-背景知识" class="headerlink" title="0x00 背景知识"></a>0x00 背景知识</h2><p>生产者和消费者是一个常见的问题，它的模型是多个生产者在生产产品，同时多个消费者消费产品，但是仓库容量是有限的，所以当仓库满了生产者需要休眠，而当仓库空了消费者需要唤醒生产者。这里面涉及的问题有互斥和同步。</p>
<h2 id="0x01-一种解决方法"><a href="#0x01-一种解决方法" class="headerlink" title="0x01 一种解决方法"></a>0x01 一种解决方法</h2><p>可以使用锁来负责互斥，使用threading.Condition来做同步。threading的完整用法见<a href="https://docs.python.org/2/library/threading.html" target="_blank" rel="external">官方文档</a>，Condition的完整用法见<a href="https://docs.python.org/2/library/threading.html#condition-objects" target="_blank" rel="external">Condition的描述</a>。简单来说，Condition内置了锁，当调用acquire()方法时，自动上锁，release()释放锁。wait()方法会释放锁后阻塞程序，直到被notify()方法唤醒。Talk is cheap, this is the code.<br><a id="more"></a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> threading</div><div class="line"><span class="keyword">import</span> random</div><div class="line"><span class="keyword">import</span> time</div><div class="line"></div><div class="line">warehouse = []</div><div class="line">max_num = <span class="number">10</span></div><div class="line">condition = threading.Condition()</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProducerThread</span><span class="params">(threading.Thread)</span>:</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">		threading.Thread.__init__(self)</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line">		<span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">			condition.acquire()</div><div class="line">			<span class="keyword">if</span> len(warehouse) == max_num:</div><div class="line">				<span class="keyword">print</span> <span class="string">"Warehouse is full"</span></div><div class="line">				condition.wait()  <span class="comment"># Release the lock</span></div><div class="line">				<span class="keyword">print</span> <span class="string">"Producer is notified by consumer"</span></div><div class="line">			<span class="keyword">else</span>:</div><div class="line">				warehouse.append(<span class="number">1</span>)</div><div class="line">				<span class="keyword">print</span> <span class="string">"Producer is working, NUM: "</span> + str(len(warehouse))</div><div class="line">			condition.notify()</div><div class="line">			condition.release()</div><div class="line">			time.sleep(random.random())</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConsumerThread</span><span class="params">(threading.Thread)</span>:</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">		threading.Thread.__init__(self)</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line">		<span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">			condition.acquire()</div><div class="line">			<span class="keyword">if</span> len(warehouse) == <span class="number">0</span>:</div><div class="line">				<span class="keyword">print</span> <span class="string">"Warehouse is empty"</span></div><div class="line">				condition.wait()</div><div class="line">				<span class="keyword">print</span> <span class="string">"Consumer is notified by producer"</span></div><div class="line">			<span class="keyword">else</span>:</div><div class="line">				warehouse.pop()</div><div class="line">				<span class="keyword">print</span> <span class="string">"Consumer is working, NUM: "</span> + str(len(warehouse))</div><div class="line">			condition.notify()</div><div class="line">			condition.release()</div><div class="line">			time.sleep(random.random())</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">	c_list = []</div><div class="line">	p_list = []</div><div class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</div><div class="line">		p = ProducerThread()</div><div class="line">		p_list.append(p)</div><div class="line">		p.start()</div><div class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>):</div><div class="line">		c = ConsumerThread()</div><div class="line">		c_list.append(c)</div><div class="line">		c.start()</div></pre></td></tr></table></figure></p>
<p>常见的错误❌代码如下，这是来自网上关于这个知识点的示例，真是天下代码一大抄啊。至于错误原因，读者不难发现。下面的代码会超过仓库的最大存储。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, Condition</div><div class="line"><span class="keyword">import</span> time</div><div class="line"><span class="keyword">import</span> random</div><div class="line"></div><div class="line">queue = []</div><div class="line">MAX_NUM = <span class="number">10</span></div><div class="line">condition = Condition()</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProducerThread</span><span class="params">(Thread)</span>:</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line">		nums = range(<span class="number">5</span>)</div><div class="line">		<span class="keyword">global</span> queue</div><div class="line">		<span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">			condition.acquire()</div><div class="line">			<span class="keyword">if</span> len(queue) == MAX_NUM:</div><div class="line">				<span class="keyword">print</span> <span class="string">"Queue full, producer is waiting"</span></div><div class="line">				condition.wait()</div><div class="line">				<span class="keyword">print</span> <span class="string">"Space in queue, Consumer notified the producer"</span></div><div class="line">			num = random.choice(nums)</div><div class="line">			queue.append(num)</div><div class="line">			<span class="keyword">print</span> <span class="string">"Produced"</span>, len(queue)</div><div class="line">			condition.notify()</div><div class="line">			condition.release()</div><div class="line">			time.sleep(random.random())</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConsumerThread</span><span class="params">(Thread)</span>:</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line">		<span class="keyword">global</span> queue</div><div class="line">		<span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">			condition.acquire()</div><div class="line">			<span class="keyword">if</span> <span class="keyword">not</span> queue:</div><div class="line">				<span class="keyword">print</span> <span class="string">"Nothing in queue, consumer is waiting"</span></div><div class="line">				condition.wait()</div><div class="line">				<span class="keyword">print</span> <span class="string">"Producer added something to queue and notified the consumer"</span></div><div class="line">			num = queue.pop(<span class="number">0</span>)</div><div class="line">			<span class="keyword">print</span> <span class="string">"Consumed"</span>, len(queue)</div><div class="line">			condition.notify()</div><div class="line">			condition.release()</div><div class="line">			time.sleep(random.random())</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">	c_list = []</div><div class="line">	p_list = []</div><div class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</div><div class="line">		p = ProducerThread()</div><div class="line">		p_list.append(p)</div><div class="line">		p.start()</div><div class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</div><div class="line">		c = ConsumerThread()</div><div class="line">		c_list.append(c)</div><div class="line">		c.start()</div></pre></td></tr></table></figure></p>
<h2 id="0x02-基于Queue的实现"><a href="#0x02-基于Queue的实现" class="headerlink" title="0x02 基于Queue的实现"></a>0x02 基于Queue的实现</h2><p>Queue模块内置了Condition，可以使用Queue同时满足互斥和同步两个要求。Queue本来就是线程安全的，而Queue的task_done()方法可以用来同步。Queue的详细使用见<a href="https://docs.python.org/2/library/queue.html" target="_blank" rel="external">官方文档</a>。这个实现代码如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> Queue</div><div class="line"><span class="keyword">import</span> threading</div><div class="line"><span class="keyword">import</span> time</div><div class="line"><span class="keyword">import</span> random</div><div class="line"></div><div class="line">product_queue = Queue.Queue(<span class="number">10</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProducerThread</span><span class="params">(threading.Thread)</span>:</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">		threading.Thread.__init__(self)</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line">		<span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">			product_queue.put(<span class="number">1</span>, block=<span class="keyword">True</span>)</div><div class="line">			time.sleep(random.random())</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConsumerThread</span><span class="params">(threading.Thread)</span>:</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">		threading.Thread.__init__(self)</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line">		<span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">			product_queue.get(block=<span class="keyword">True</span>)</div><div class="line">			product_queue.task_done()</div><div class="line">			time.sleep(random.random())</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">	c_list = []</div><div class="line">	p_list = []</div><div class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</div><div class="line">		p = ProducerThread()</div><div class="line">		p_list.append(p)</div><div class="line">		p.start()</div><div class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</div><div class="line">		c = ConsumerThread()</div><div class="line">		c_list.append(c)</div><div class="line">		c.start()</div></pre></td></tr></table></figure></p>
<p>Queue也是用Condition来实现的，注意:</p>
<blockquote>
<p>Note: the notify() and notifyAll() methods don’t release the lock; this means that the thread or threads awakened will not return from their wait() call immediately, but only when the thread that called notify() or notifyAll() finally relinquishes ownership of the lock.</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x00-背景知识&quot;&gt;&lt;a href=&quot;#0x00-背景知识&quot; class=&quot;headerlink&quot; title=&quot;0x00 背景知识&quot;&gt;&lt;/a&gt;0x00 背景知识&lt;/h2&gt;&lt;p&gt;生产者和消费者是一个常见的问题，它的模型是多个生产者在生产产品，同时多个消费者消费产品，但是仓库容量是有限的，所以当仓库满了生产者需要休眠，而当仓库空了消费者需要唤醒生产者。这里面涉及的问题有互斥和同步。&lt;/p&gt;
&lt;h2 id=&quot;0x01-一种解决方法&quot;&gt;&lt;a href=&quot;#0x01-一种解决方法&quot; class=&quot;headerlink&quot; title=&quot;0x01 一种解决方法&quot;&gt;&lt;/a&gt;0x01 一种解决方法&lt;/h2&gt;&lt;p&gt;可以使用锁来负责互斥，使用threading.Condition来做同步。threading的完整用法见&lt;a href=&quot;https://docs.python.org/2/library/threading.html&quot;&gt;官方文档&lt;/a&gt;，Condition的完整用法见&lt;a href=&quot;https://docs.python.org/2/library/threading.html#condition-objects&quot;&gt;Condition的描述&lt;/a&gt;。简单来说，Condition内置了锁，当调用acquire()方法时，自动上锁，release()释放锁。wait()方法会释放锁后阻塞程序，直到被notify()方法唤醒。Talk is cheap, this is the code.&lt;br&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://blog.nudtcat.org/tags/Python/"/>
    
      <category term="操作系统" scheme="http://blog.nudtcat.org/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>珍惜大学仅剩的一年</title>
    <link href="http://blog.nudtcat.org/default/%E7%8F%8D%E6%83%9C%E5%A4%A7%E5%AD%A6%E4%BB%85%E5%89%A9%E7%9A%84%E4%B8%80%E5%B9%B4/"/>
    <id>http://blog.nudtcat.org/default/珍惜大学仅剩的一年/</id>
    <published>2016-09-23T14:15:59.000Z</published>
    <updated>2016-09-24T03:34:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>珍惜最后一年的大学生活</p>
<ul>
<li>写一篇优秀的毕业论文</li>
<li>在大雨天跑一次步</li>
<li>感受教学楼，图书馆，读几本书</li>
<li>毕业旅行</li>
<li>来一次冒险(骑行||徒步)<a id="more"></a>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;珍惜最后一年的大学生活&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;写一篇优秀的毕业论文&lt;/li&gt;
&lt;li&gt;在大雨天跑一次步&lt;/li&gt;
&lt;li&gt;感受教学楼，图书馆，读几本书&lt;/li&gt;
&lt;li&gt;毕业旅行&lt;/li&gt;
&lt;li&gt;来一次冒险(骑行||徒步)
    
    </summary>
    
    
      <category term="大学生活" scheme="http://blog.nudtcat.org/tags/%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
</feed>
