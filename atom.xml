<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>喜欢冒险探索的程序猿</title>
  <subtitle>喜欢冒险探索的程序猿</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.nudtcat.org/"/>
  <updated>2016-09-28T03:12:02.000Z</updated>
  <id>http://blog.nudtcat.org/</id>
  
  <author>
    <name>nudtcat</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于信任的反思</title>
    <link href="http://blog.nudtcat.org/Chat/%E5%85%B3%E4%BA%8E%E4%BF%A1%E4%BB%BB%E7%9A%84%E5%8F%8D%E6%80%9D/"/>
    <id>http://blog.nudtcat.org/Chat/关于信任的反思/</id>
    <published>2016-09-25T11:54:22.000Z</published>
    <updated>2016-09-28T03:12:02.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-信任"><a href="#0x01-信任" class="headerlink" title="0x01 信任"></a>0x01 信任</h2><p>很多安全事件的问题都出现在信任上，上层模块对底层模块的信任，人对软件的信任，人对人的信任，都是安全问题频发的地方。<br><a id="more"></a></p>
<h2 id="0x02-被证实的信任危机"><a href="#0x02-被证实的信任危机" class="headerlink" title="0x02 被证实的信任危机"></a>0x02 被证实的信任危机</h2><ul>
<li>XcodeGhost事件：开发人员对编译器的信任</li>
<li>BadUSB：操作系统对外设的信任</li>
<li>条形码扫描器漏洞</li>
</ul>
<h2 id="0x03-被滥用的信任"><a href="#0x03-被滥用的信任" class="headerlink" title="0x03 被滥用的信任"></a>0x03 被滥用的信任</h2><ul>
<li>杀毒软件对下载站的信任：各种下载站的捆绑软件，静默安装行为无疑具有恶意软件的行为特征，但是杀毒软件基本不查杀，一旦下载站被种马，后果非常严重</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x01-信任&quot;&gt;&lt;a href=&quot;#0x01-信任&quot; class=&quot;headerlink&quot; title=&quot;0x01 信任&quot;&gt;&lt;/a&gt;0x01 信任&lt;/h2&gt;&lt;p&gt;很多安全事件的问题都出现在信任上，上层模块对底层模块的信任，人对软件的信任，人对人的信任，都是安全问题频发的地方。&lt;br&gt;
    
    </summary>
    
      <category term="杂谈" scheme="http://blog.nudtcat.org/categories/Chat/"/>
    
    
      <category term="安全" scheme="http://blog.nudtcat.org/tags/%E5%AE%89%E5%85%A8/"/>
    
      <category term="update" scheme="http://blog.nudtcat.org/tags/update/"/>
    
      <category term="信任" scheme="http://blog.nudtcat.org/tags/%E4%BF%A1%E4%BB%BB/"/>
    
  </entry>
  
  <entry>
    <title>从一个简单的RFID安全事件说起</title>
    <link href="http://blog.nudtcat.org/RFID/%E4%BB%8E%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84RFID%E5%AE%89%E5%85%A8%E4%BA%8B%E4%BB%B6%E8%AF%B4%E8%B5%B7/"/>
    <id>http://blog.nudtcat.org/RFID/从一个简单的RFID安全事件说起/</id>
    <published>2016-09-25T04:41:49.000Z</published>
    <updated>2016-09-28T01:43:11.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-know-it"><a href="#0x01-know-it" class="headerlink" title="0x01 know it"></a>0x01 know it</h2><p>学校新增了一个微信洗衣系统，用起来相当简单，首先，在系统的微信公众号上注册一个账户，账户是使用openid作为cookie，openid是微信生成的，只有在关注了公众号的时候才会产生。openid由几个因素决定，一个是公众号的appid，另一个是关注者的微信id。openid的作用就是让微信公众号的开发者唯一标识一个关注者。然后，将账户与任一一张卡绑定起来(我们学校有水卡和一卡通两张卡)。洗衣系统的充值使用微信支付，余额跟着微信走。<br><a id="more"></a><br>也就是说，整个结构就是线上存着你的各种信息以及余额，怎么去使用余额洗衣呢？就依靠你手上的卡，这张卡与系统进行了绑定，拿到卡，就拿到了系统的通行证。洗衣的时候拿着卡在洗衣机终端上刷一下，即可验证身份，使用余额。</p>
<h2 id="0x02-key-point"><a href="#0x02-key-point" class="headerlink" title="0x02 key point"></a>0x02 key point</h2><p>那么卡与系统是怎么绑定的呢？在系统中，每个账户都可以绑定一个物理卡ID，如图所示：<img src="/images/0925_01.png" alt=""><br>当然，普通人肯定不知道一张卡的物理卡ID是多少，于是，洗衣机终端就承担了这个功能。当一张未绑定的卡去刷洗衣机终端时，终端显示如下</p>
<p><img src="/images/0925_02.png" alt=""></p>
<p>然后只需要在系统中绑定这个物理卡号即可。绑定后正常使用的照片如下图<img src="/images/0925_03.png" alt=""></p>
<h2 id="0x03-analysis-it"><a href="#0x03-analysis-it" class="headerlink" title="0x03 analysis it"></a>0x03 analysis it</h2><p>我们重点分析一下这个鉴权过程，系统使用物理卡ID来唯一标识用户，而我们使用的卡都是M1卡，M1卡中存储着UID和block，block的访问是需要密码的，而洗衣系统和一卡通是不同的公司开发的，所以肯定不是使用block中存储的数据来唯一标识用户，而每张M1卡的UID都是唯一的，但是可以通过可写入的白卡写入相同的UID。关于RFID和M1卡的相关知识以及安全漏洞请自行Google。所以这个物理卡ID应该就是M1卡的UID。遂试验之，果然，连最简单的映射都没有做</p>
<p><img src="/images/0925_04.png" alt=""><br><img src="/images/0925_05.png" alt=""></p>
<p>我们看上面洗衣终端正常工作的照片，发现终端居然直接将卡ID赤裸裸展示出来，这不是直接把密码输出了嘛！</p>
<h2 id="0x04-hack-it"><a href="#0x04-hack-it" class="headerlink" title="0x04 hack it"></a>0x04 hack it</h2><p>分析到这里，用别人的余额洗衣就非常容易了。只需要在洗衣终端上读到一卡通卡号，把它作为UID写入白卡即可。</p>
<h2 id="0x05-躺枪的其它系统"><a href="#0x05-躺枪的其它系统" class="headerlink" title="0x05 躺枪的其它系统"></a>0x05 躺枪的其它系统</h2><p>到这里就结束了吗？</p>
<p>我曾经丢失过自己的一卡通，补办后发现刚开始的一段时间无法打开门禁。这说明什么问题呢？补办的一卡通和原来的一卡通唯一的区别就在UID上。也就是说，补办后，在中央数据库中，我的UID有更新，而门禁需要一段时间同步更新，那么，门禁也是靠UID来识别身份的。</p>
<p>只有门禁吗？</p>
<p>一个学校的系统各种各样，门禁，闸机，多媒体讲台，一个同学或者老师的权限都由统一认证系统来确定，那么，我们从程序员和系统设计者的角度来想，这个统一认证系统肯定留了API，来供其他系统调用，鉴权。这样的设计容易扩展，更容易与其他系统配合，它的市场竞争力就会强。果然，经过试验，图书馆的闸机也是用UID来验证，而且还会显示出卡对应的名字和院系。</p>
<p>黑客永远抵抗不了root权限的诱惑，如果我们能拿到这个API，那么。。。。嘿嘿嘿。。。。</p>
<p>于是就有了下面这张照片，成功伪造了一张校长的卡</p>
<p><img src="/images/0925_06.jpg" alt=""></p>
<h2 id="0x06-p-s"><a href="#0x06-p-s" class="headerlink" title="0x06 p.s."></a>0x06 p.s.</h2><p>光拿到UID不能伪造出可以消费的一卡通，一卡通的消费是实时服务器校验的，而且在block中，对余额以及身份信息做了摘要，如果不知道摘要算法，无法伪造一张合法的卡</p>
<p>M1卡早就被曝出加密算法具有重大缺陷，具体可以Google，读卡器使用的是ACR122U。RFID安全也是安全的一个维度，国内有RadioWar团队研究比较深入。</p>
<h2 id="0x07-想到的"><a href="#0x07-想到的" class="headerlink" title="0x07 想到的"></a>0x07 想到的</h2><p>安全永远不止那么简单，一个小小的设计缺陷–显示了卡的UID，导致了所有基于UID的鉴权全部崩溃。有的时候，一个小口子，就能瞬间将精心构建的安全防护体系毁于一旦。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x01-know-it&quot;&gt;&lt;a href=&quot;#0x01-know-it&quot; class=&quot;headerlink&quot; title=&quot;0x01 know it&quot;&gt;&lt;/a&gt;0x01 know it&lt;/h2&gt;&lt;p&gt;学校新增了一个微信洗衣系统，用起来相当简单，首先，在系统的微信公众号上注册一个账户，账户是使用openid作为cookie，openid是微信生成的，只有在关注了公众号的时候才会产生。openid由几个因素决定，一个是公众号的appid，另一个是关注者的微信id。openid的作用就是让微信公众号的开发者唯一标识一个关注者。然后，将账户与任一一张卡绑定起来(我们学校有水卡和一卡通两张卡)。洗衣系统的充值使用微信支付，余额跟着微信走。&lt;br&gt;
    
    </summary>
    
      <category term="RFID" scheme="http://blog.nudtcat.org/categories/RFID/"/>
    
    
      <category term="RFID" scheme="http://blog.nudtcat.org/tags/RFID/"/>
    
      <category term="安全" scheme="http://blog.nudtcat.org/tags/%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>CRLF注入</title>
    <link href="http://blog.nudtcat.org/WebSecurity/CRLF%E6%B3%A8%E5%85%A5/"/>
    <id>http://blog.nudtcat.org/WebSecurity/CRLF注入/</id>
    <published>2016-09-25T02:33:16.000Z</published>
    <updated>2016-09-28T03:13:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-简介"><a href="#0x01-简介" class="headerlink" title="0x01 简介"></a>0x01 简介</h2><p>在HTTP协议中，HTTP请求与响应的各个字段之间的分隔符为\r\n，即CRLF。如果我们能在HTTP<strong>响应</strong>部分注入CRLF，并且加入自己的一部分代码，浏览器就会接受并且解析HTTP响应，完成我们想要的功能。<br><a id="more"></a></p>
<h2 id="0x02-危害"><a href="#0x02-危害" class="headerlink" title="0x02 危害"></a>0x02 危害</h2><p>能注入HTTP响应部分，我们能干啥呢？HTTP响应分为head部分和body部分，head部分各个字段之间的分隔是\r\n，head与body的分隔是\r\n。我们可以注入到body中，加入javascript代码，形成xss攻击。只要能注入代码到body部分，所有在浏览器层面的攻击都能实行。</p>
<p>另一个常见的攻击是注入头部，给当前的会话设置cookie，如果存在会话固定漏洞，那么就能获得用户对应的权限。</p>
<h2 id="0x03-会话固定漏洞"><a href="#0x03-会话固定漏洞" class="headerlink" title="0x03 会话固定漏洞"></a>0x03 会话固定漏洞</h2><p>在CRLF注入head部分，设置cookie后，如果服务器接受了这个cookie，并且在用户登录后不改变这个cookie，那么攻击者就能使用这个cookie，拿到和合法用户一样的权限。</p>
<h2 id="0x04-攻击方法"><a href="#0x04-攻击方法" class="headerlink" title="0x04 攻击方法"></a>0x04 攻击方法</h2><p>常见的攻击点在重定向的地方，如果没做过滤或者其它安全设置，直接在跳转的url后加上\r\n和要插入的代码，例如<a href="http://www.a.com/go.php?target=http://www.b.com\r\n\r\n" target="_blank" rel="external">http://www.a.com/go.php?target=http://www.b.com\r\n\r\n</a><script>alert(xss)</script>将这个url发送给要攻击的用户，ta点击了这个链接就会被攻击。在插入xss时，可能会被浏览器的xss filter阻止，只要在head部分插入X-XSS-Protection:0即可禁止浏览器的xss保护策略。另外，在location后面的javascript代码只会在内核为webkit的浏览器中运行。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x01-简介&quot;&gt;&lt;a href=&quot;#0x01-简介&quot; class=&quot;headerlink&quot; title=&quot;0x01 简介&quot;&gt;&lt;/a&gt;0x01 简介&lt;/h2&gt;&lt;p&gt;在HTTP协议中，HTTP请求与响应的各个字段之间的分隔符为\r\n，即CRLF。如果我们能在HTTP&lt;strong&gt;响应&lt;/strong&gt;部分注入CRLF，并且加入自己的一部分代码，浏览器就会接受并且解析HTTP响应，完成我们想要的功能。&lt;br&gt;
    
    </summary>
    
      <category term="Web安全" scheme="http://blog.nudtcat.org/categories/WebSecurity/"/>
    
    
      <category term="Web安全" scheme="http://blog.nudtcat.org/tags/Web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>宽字节注入问题</title>
    <link href="http://blog.nudtcat.org/WebSecurity/%E5%AE%BD%E5%AD%97%E8%8A%82%E6%B3%A8%E5%85%A5%E9%97%AE%E9%A2%98/"/>
    <id>http://blog.nudtcat.org/WebSecurity/宽字节注入问题/</id>
    <published>2016-09-25T01:23:19.000Z</published>
    <updated>2016-09-28T03:12:19.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-宽字节"><a href="#0x00-宽字节" class="headerlink" title="0x00 宽字节"></a>0x00 宽字节</h2><p>在代码注入攻击中，宽字节问题已经是老生常谈。注意，这里的代码注入是指宽泛的代码注入：<strong>所有突破数据与代码边界，使数据注入代码段，变成可执行代码</strong>的攻击手法都可以叫代码注入，包括SQL注入和XSS。啥是宽字节呢？其实就是用多个字节表示一个字符。<br><a id="more"></a></p>
<h2 id="0x01-另一个角度看MySQL的宽字节注入问题"><a href="#0x01-另一个角度看MySQL的宽字节注入问题" class="headerlink" title="0x01 另一个角度看MySQL的宽字节注入问题"></a>0x01 另一个角度看MySQL的宽字节注入问题</h2><p>先说说MySQL中的宽字节注入，MySQL在接受到php传来的SQL语句时，会使用MySQL设置中的character_set_client设置值进行编码。而如果character_set_client是一个宽字符集，那么可能会将SQL语句中的多个字节编码成一个字符，这样就改变了SQL语句的原意。我们对这个编码前的SQL语句稍加控制，使编码编掉一些字符，比如\，这样就能绕过php层的安全策略。说起来可能略抽象，下面打一个简单的比方。</p>
<p>实验环境：magic_quotes_gpc=Off，php代码如下<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">$a=$_GET[<span class="string">'a'</span>];</div><div class="line">$a=addslashes($a);</div><div class="line"><span class="keyword">print</span> <span class="string">"select * from admin where name='"</span>.$a.<span class="string">"'"</span>;</div></pre></td></tr></table></figure></p>
<p>代码非常简单，将传入的a使用addslashes函数转义，转义掉单引号等字符。我们请求<a href="http://115.28.188.93/1.php?a=admin%df" target="_blank" rel="external">http://115.28.188.93/1.php?a=admin%df</a>‘ and 1=1 – s抓包，看到的响应如下图<br><img src="/images/0924_01.png" alt=""><br>红色框中被选中的内容就是响应的内容，这个是二进制的，可以看做是SQL语句在传给MySQL的时候的状态。这个时候，浏览器的返回时这样的(浏览器编码设置为UTF-8)<br><img src="/images/0924_02.png" alt=""></p>
<p>在这里，浏览器设置的编码相当于MySQL的character_set_client，浏览器会对http响应的部分做编码，MySQL也是一样，这种情况下，我们发现我们请求中的单引号已经被转义了，无法形成SQL注入。我们把浏览器编码设置为gbk，再看看<br><img src="/images/0924_03.png" alt=""></p>
<p>这个时候，我们发现\不见了，我们插入的单引号成功闭合了前面的单引号，and 1=1已经插入到了SQL语句代码部分，能影响SQL语句的逻辑。也就是说，这个时候，我们相当于把MySQL的character_set_client设置成了gbk，成功引发了宽字节的注入问题，这就是整个数据流的流向，最复杂的一部分已经弄清楚了，下面就是一些细节问题了。</p>
<p>在admin%df’被addslashes后，结果是admin%df\’,也就是admin%df%5c%27,而将其转换为gbk编码后，%df%5c代表一个中文字符，然后就被编码成運，喜闻乐见的，我们的单引号就被插入了。</p>
<p>(题外话：不同浏览器在得到一个没有指定编码的html响应时可能会采用不同的编码，我的Chrome和Firefox就是这样。所以，请手动设置编码方式)</p>
<p>哪些范围会被gbk编码成汉字呢？根据gbk编码，第一个字节ascii码大于128，基本上就可以了。如果character_set_client是gb2312，能不能成功呢？理论上来说，只要\，也就是%5c在某些字符集的低位中，都是可以的，不巧，gb2312的低位范围是0xA1~0xFE，所以不可以。</p>
<h2 id="0x03-初衷"><a href="#0x03-初衷" class="headerlink" title="0x03 初衷"></a>0x03 初衷</h2><p>我为啥写这篇文章？phithon在Freebuf上的<a href="http://www.freebuf.com/articles/web/31537.html" target="_blank" rel="external">浅析白盒审计中的字符编码及SQL注入</a>写得非常好，但是我认为在SQL语句的流向方面写得不够详细，我做了一点补充，其余内容请参看phithon大神的文章。如果有什么不明白，那多半是SQL语句的流向以及编码状态不明白，可以参考我上面浏览器编码的比喻。</p>
<h2 id="0x04-意识"><a href="#0x04-意识" class="headerlink" title="0x04 意识"></a>0x04 意识</h2><p>玩儿英雄联盟的人都知道，意识最为重要。做安全也是如此，意识本质上是安全观。宽字节的问题，有可能改头换面出现在另一个地方，就看下次遇到的时候，谁能思考得深，看到更内在的东西了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x00-宽字节&quot;&gt;&lt;a href=&quot;#0x00-宽字节&quot; class=&quot;headerlink&quot; title=&quot;0x00 宽字节&quot;&gt;&lt;/a&gt;0x00 宽字节&lt;/h2&gt;&lt;p&gt;在代码注入攻击中，宽字节问题已经是老生常谈。注意，这里的代码注入是指宽泛的代码注入：&lt;strong&gt;所有突破数据与代码边界，使数据注入代码段，变成可执行代码&lt;/strong&gt;的攻击手法都可以叫代码注入，包括SQL注入和XSS。啥是宽字节呢？其实就是用多个字节表示一个字符。&lt;br&gt;
    
    </summary>
    
      <category term="Web安全" scheme="http://blog.nudtcat.org/categories/WebSecurity/"/>
    
    
      <category term="Web安全" scheme="http://blog.nudtcat.org/tags/Web%E5%AE%89%E5%85%A8/"/>
    
      <category term="SQL注入" scheme="http://blog.nudtcat.org/tags/SQL%E6%B3%A8%E5%85%A5/"/>
    
      <category term="宽字节" scheme="http://blog.nudtcat.org/tags/%E5%AE%BD%E5%AD%97%E8%8A%82/"/>
    
  </entry>
  
  <entry>
    <title>Python装饰器</title>
    <link href="http://blog.nudtcat.org/Python/Python%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    <id>http://blog.nudtcat.org/Python/Python装饰器/</id>
    <published>2016-09-24T03:36:54.000Z</published>
    <updated>2016-09-28T03:13:23.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-语法糖"><a href="#0x00-语法糖" class="headerlink" title="0x00 语法糖"></a>0x00 语法糖</h2><p>装饰器是Python一个语法糖，装饰器就是在不改变原函数的基础上，在原函数前后执行一些代码，就好像在原函数上增加了一些装饰品一样。这个语法能非常方便给一个函数增加一些功能，例如权限控制，校验一个函数的输入等。<br><a id="more"></a></p>
<h2 id="0x01-语法原理"><a href="#0x01-语法原理" class="headerlink" title="0x01 语法原理"></a>0x01 语法原理</h2><h3 id="最简单的情况"><a href="#最简单的情况" class="headerlink" title="最简单的情况"></a>最简单的情况</h3><p>装饰一个有参数的函数<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span><span class="params">(func)</span>:</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args,**kwargs)</span>:</span></div><div class="line">		res=func(*args,**kwargs)</div><div class="line">		<span class="keyword">print</span> <span class="string">"function "</span>+func.__name__+<span class="string">" return "</span>+str(res)</div><div class="line">		<span class="keyword">return</span> res</div><div class="line">	<span class="keyword">return</span> wrapper</div><div class="line"></div><div class="line"><span class="meta">@debug</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">(a, b)</span>:</span></div><div class="line">	<span class="keyword">return</span> a + b</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</div><div class="line">	<span class="keyword">print</span> sum(<span class="number">1</span>,<span class="number">3</span>)</div></pre></td></tr></table></figure></p>
<p>运行结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">function sum return 4</div><div class="line">4</div></pre></td></tr></table></figure></p>
<p>这里展示了装饰器最基本的使用，给sum函数添加了debug这个装饰，这个装饰器在sum函数调用之后输出了函数名和返回值方便调试。我们看一下这个语法糖的真面目。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span><span class="params">(func)</span>:</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args,**kwargs)</span>:</span></div><div class="line">		res=func(*args,**kwargs)</div><div class="line">		<span class="keyword">print</span> <span class="string">"function "</span>+func.__name__+<span class="string">" return "</span>+str(res)</div><div class="line">		<span class="keyword">return</span> res</div><div class="line">	<span class="keyword">return</span> wrapper</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">(a, b)</span>:</span></div><div class="line">	<span class="keyword">return</span> a + b</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</div><div class="line">	<span class="keyword">print</span> debug(sum)(<span class="number">1</span>,<span class="number">3</span>)</div><div class="line">	<span class="keyword">print</span> <span class="string">"==== function ===="</span></div><div class="line">	<span class="keyword">print</span> debug</div><div class="line">	<span class="keyword">print</span> debug(sum)</div></pre></td></tr></table></figure></p>
<p>运行结果为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">function sum return 4</div><div class="line">4</div><div class="line">==== function ====</div><div class="line">&lt;function debug at 0x1044c0de8&gt;</div><div class="line">&lt;function wrapper at 0x1044c0ed8&gt;</div></pre></td></tr></table></figure></p>
<p>在有装饰器的时候，调用sum(1,3)相当于调用了debug(sum)(1,3)。我们来分析一下debug(sum)(1,3)这个调用。在Python中，万物皆对象，类是一个对象，方法也是一个对象。例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">(a, b)</span>:</span></div><div class="line">	<span class="keyword">return</span> a + b</div></pre></td></tr></table></figure></p>
<p>定义了一个sum方法，同时，sum也是一个对象，它的类型是函数。sum的值是一个入口在某地址的函数。sum(1,2)就是对这个函数的调用。我们回到debug(sum)(1,3)这个函数调用，首先调用了debug这个函数，它的参数是一个函数，我们根据<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span><span class="params">(func)</span>:</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args,**kwargs)</span>:</span></div><div class="line">		res=func(*args,**kwargs)</div><div class="line">		<span class="keyword">print</span> <span class="string">"function "</span>+func.__name__+<span class="string">" return "</span>+str(res)</div><div class="line">		<span class="keyword">return</span> res</div><div class="line">	<span class="keyword">return</span> wrapper</div></pre></td></tr></table></figure></p>
<p>return wrapper表示这个函数的返回值是一个函数，即debug(sum)(1,3)相当于wrapper(1,3)。wrapper(1,3)即对wrapper函数的调用。这样，把装饰器函数的定义和语法糖背后的代码结合理解，很容易理解装饰器这个概念和@debug这样的语法。</p>
<h3 id="带参数的情况"><a href="#带参数的情况" class="headerlink" title="带参数的情况"></a>带参数的情况</h3><p>装饰器也可以带参数，这里可能比上面稍微复杂一点，如果上面的还有一点疑惑，多看两遍，在看接下来的。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">is_debug=<span class="keyword">True</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span><span class="params">(is_debug)</span>:</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(func)</span>:</span></div><div class="line">		<span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">(*args,**kwargs)</span>:</span></div><div class="line">			res=func(*args,**kwargs)</div><div class="line">			<span class="keyword">if</span>(is_debug):</div><div class="line">				<span class="keyword">print</span> <span class="string">"function "</span> + func.__name__ + <span class="string">" return "</span> + str(res)</div><div class="line">			<span class="keyword">return</span> res</div><div class="line">		<span class="keyword">return</span> inner</div><div class="line">	<span class="keyword">return</span> wrapper</div><div class="line"></div><div class="line"><span class="meta">@debug(is_debug)</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">(a, b)</span>:</span></div><div class="line">	<span class="keyword">return</span> a + b</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</div><div class="line">	<span class="keyword">print</span> sum(<span class="number">1</span>,<span class="number">3</span>)</div></pre></td></tr></table></figure></p>
<p>在这里，我们定义了一个全局变量is_debug来控制是否输出debug信息，这个值是装饰器的参数。感觉在装饰器定义多层函数，还有不同的参数，完全分不清啊有木有!<br>我们来看与上面等价的调用<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">is_debug=<span class="keyword">True</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span><span class="params">(is_debug)</span>:</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(func)</span>:</span></div><div class="line">		<span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">(*args,**kwargs)</span>:</span></div><div class="line">			res=func(*args,**kwargs)</div><div class="line">			<span class="keyword">if</span>(is_debug):</div><div class="line">				<span class="keyword">print</span> <span class="string">"function "</span> + func.__name__ + <span class="string">" return "</span> + str(res)</div><div class="line">			<span class="keyword">return</span> res</div><div class="line">		<span class="keyword">return</span> inner</div><div class="line">	<span class="keyword">return</span> wrapper</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">(a, b)</span>:</span></div><div class="line">	<span class="keyword">return</span> a + b</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</div><div class="line">	<span class="keyword">print</span> debug(is_debug)(sum)(<span class="number">1</span>,<span class="number">3</span>)</div><div class="line">	<span class="keyword">print</span> <span class="string">"==== function ===="</span></div><div class="line">	<span class="keyword">print</span> debug</div><div class="line">	<span class="keyword">print</span> debug(is_debug)</div><div class="line">	<span class="keyword">print</span> debug(is_debug)(sum)</div></pre></td></tr></table></figure></p>
<p>下面是运行结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">function sum return 4</div><div class="line">4</div><div class="line">==== function ====</div><div class="line">&lt;function debug at 0x10b079e60&gt;</div><div class="line">&lt;function wrapper at 0x10b079f50&gt;</div><div class="line">&lt;function inner at 0x10b08e050&gt;</div></pre></td></tr></table></figure></p>
<p>其实，看懂这个调用的方法跟上面是一样的。不再赘述，值得一提的是这里，其实debug(is_debug)返回的这个函数可以认为是另一个没有参数的装饰器，然后整个结构就上面没有参数的情况一样了。这个新的装饰器的参数是函数，即debug(is_debug)(sum)，然后返回一个参数是<em>args,*</em>kwargs的函数，再调用这个函数，参数为1，3。即完成整个调用。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x00-语法糖&quot;&gt;&lt;a href=&quot;#0x00-语法糖&quot; class=&quot;headerlink&quot; title=&quot;0x00 语法糖&quot;&gt;&lt;/a&gt;0x00 语法糖&lt;/h2&gt;&lt;p&gt;装饰器是Python一个语法糖，装饰器就是在不改变原函数的基础上，在原函数前后执行一些代码，就好像在原函数上增加了一些装饰品一样。这个语法能非常方便给一个函数增加一些功能，例如权限控制，校验一个函数的输入等。&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://blog.nudtcat.org/categories/Python/"/>
    
    
      <category term="Python" scheme="http://blog.nudtcat.org/tags/Python/"/>
    
      <category term="装饰器" scheme="http://blog.nudtcat.org/tags/%E8%A3%85%E9%A5%B0%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>一个简单的爬虫</title>
    <link href="http://blog.nudtcat.org/Python/%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E7%88%AC%E8%99%AB/"/>
    <id>http://blog.nudtcat.org/Python/一个简单的爬虫/</id>
    <published>2016-09-24T03:31:03.000Z</published>
    <updated>2016-09-28T03:12:46.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x01-初衷"><a href="#0x01-初衷" class="headerlink" title="0x01 初衷"></a>0x01 初衷</h2><p>最近准备开始写一些通用的自动化工具，以前也写过一些自动化的东西，不过都是用胶水把一些现成的工具粘连起来而已。自己开始写工具并不只是造轮子，我希望把尽自己最大的努力，每一个模块都做到最细致，规则做到最好，所以这个project会持续很长的时间，而且有可能会重构很多次。<br><a id="more"></a></p>
<h2 id="0x02-设计"><a href="#0x02-设计" class="headerlink" title="0x02 设计"></a>0x02 设计</h2><p>这个爬虫的作用是从一个网页作为开始，爬取相关联的网页。需要注意的有几个点，一是从html中获取链接，使用有很多种方法都可以形成链接的效果，获取链接同样有很多解决方案。二是多线程问题，可以使用简单的线程池，重点在于多线程下的同步和互斥的问题。我在<a href="http://blog.nudtcat.org/default/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98%E7%9A%84Python%E5%AE%9E%E7%8E%B0/">生产者消费者问题的Python实现</a>中说到过，其实链接队列就是这个模型，解析模块不停生产链接，插入queue，request模块不停从queue中获取链接，然后将html交给解析模块。解决方法可以看这篇文章。三是链接去重问题，最差的时间复杂度是O(n)，如果链接不多，内存足够，时间复杂度可以到O(1)，但是怎么在大数量级的情况下快速判断一个链接是否重复，是一个难题，但是也有现成的解决方案。另一个问题是具体的规则，同一个页面，不同的锚点可以被优化为只爬取一次。</p>
<p>以上的三个问题，每个问题都可以作为单独一个project深入研究下去，但是那就是software engineer的范畴了。</p>
<h2 id="0x03-简单的设计"><a href="#0x03-简单的设计" class="headerlink" title="0x03 简单的设计"></a>0x03 简单的设计</h2><p>我不喜欢啥都不说，虽然talk is cheap，show me the code。但是把要点说出来，更容易让初学者把握。我写了一个简单的实现，见<a href="https://github.com/nudtcat/simple_crawler/" target="_blank" rel="external">我的github</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x01-初衷&quot;&gt;&lt;a href=&quot;#0x01-初衷&quot; class=&quot;headerlink&quot; title=&quot;0x01 初衷&quot;&gt;&lt;/a&gt;0x01 初衷&lt;/h2&gt;&lt;p&gt;最近准备开始写一些通用的自动化工具，以前也写过一些自动化的东西，不过都是用胶水把一些现成的工具粘连起来而已。自己开始写工具并不只是造轮子，我希望把尽自己最大的努力，每一个模块都做到最细致，规则做到最好，所以这个project会持续很长的时间，而且有可能会重构很多次。&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://blog.nudtcat.org/categories/Python/"/>
    
    
      <category term="爬虫" scheme="http://blog.nudtcat.org/tags/%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>生产者消费者问题的Python实现</title>
    <link href="http://blog.nudtcat.org/Python/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98%E7%9A%84Python%E5%AE%9E%E7%8E%B0/"/>
    <id>http://blog.nudtcat.org/Python/生产者消费者问题的Python实现/</id>
    <published>2016-09-24T03:13:48.000Z</published>
    <updated>2016-09-28T03:12:33.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="0x00-背景知识"><a href="#0x00-背景知识" class="headerlink" title="0x00 背景知识"></a>0x00 背景知识</h2><p>生产者和消费者是一个常见的问题，它的模型是多个生产者在生产产品，同时多个消费者消费产品，但是仓库容量是有限的，所以当仓库满了生产者需要休眠，而当仓库空了消费者需要唤醒生产者。这里面涉及的问题有互斥和同步。</p>
<h2 id="0x01-一种解决方法"><a href="#0x01-一种解决方法" class="headerlink" title="0x01 一种解决方法"></a>0x01 一种解决方法</h2><p>可以使用锁来负责互斥，使用threading.Condition来做同步。threading的完整用法见<a href="https://docs.python.org/2/library/threading.html" target="_blank" rel="external">官方文档</a>，Condition的完整用法见<a href="https://docs.python.org/2/library/threading.html#condition-objects" target="_blank" rel="external">Condition的描述</a>。简单来说，Condition内置了锁，当调用acquire()方法时，自动上锁，release()释放锁。wait()方法会释放锁后阻塞程序，直到被notify()方法唤醒。Talk is cheap, this is the code.<br><a id="more"></a><br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> threading</div><div class="line"><span class="keyword">import</span> random</div><div class="line"><span class="keyword">import</span> time</div><div class="line"></div><div class="line">warehouse = []</div><div class="line">max_num = <span class="number">10</span></div><div class="line">condition = threading.Condition()</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProducerThread</span><span class="params">(threading.Thread)</span>:</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">		threading.Thread.__init__(self)</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line">		<span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">			condition.acquire()</div><div class="line">			<span class="keyword">if</span> len(warehouse) == max_num:</div><div class="line">				<span class="keyword">print</span> <span class="string">"Warehouse is full"</span></div><div class="line">				condition.wait()  <span class="comment"># Release the lock</span></div><div class="line">				<span class="keyword">print</span> <span class="string">"Producer is notified by consumer"</span></div><div class="line">			<span class="keyword">else</span>:</div><div class="line">				warehouse.append(<span class="number">1</span>)</div><div class="line">				<span class="keyword">print</span> <span class="string">"Producer is working, NUM: "</span> + str(len(warehouse))</div><div class="line">			condition.notify()</div><div class="line">			condition.release()</div><div class="line">			time.sleep(random.random())</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConsumerThread</span><span class="params">(threading.Thread)</span>:</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">		threading.Thread.__init__(self)</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line">		<span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">			condition.acquire()</div><div class="line">			<span class="keyword">if</span> len(warehouse) == <span class="number">0</span>:</div><div class="line">				<span class="keyword">print</span> <span class="string">"Warehouse is empty"</span></div><div class="line">				condition.wait()</div><div class="line">				<span class="keyword">print</span> <span class="string">"Consumer is notified by producer"</span></div><div class="line">			<span class="keyword">else</span>:</div><div class="line">				warehouse.pop()</div><div class="line">				<span class="keyword">print</span> <span class="string">"Consumer is working, NUM: "</span> + str(len(warehouse))</div><div class="line">			condition.notify()</div><div class="line">			condition.release()</div><div class="line">			time.sleep(random.random())</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">	c_list = []</div><div class="line">	p_list = []</div><div class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</div><div class="line">		p = ProducerThread()</div><div class="line">		p_list.append(p)</div><div class="line">		p.start()</div><div class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>):</div><div class="line">		c = ConsumerThread()</div><div class="line">		c_list.append(c)</div><div class="line">		c.start()</div></pre></td></tr></table></figure></p>
<p>常见的错误❌代码如下，这是来自网上关于这个知识点的示例，真是天下代码一大抄啊。至于错误原因，读者不难发现。下面的代码会超过仓库的最大存储。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, Condition</div><div class="line"><span class="keyword">import</span> time</div><div class="line"><span class="keyword">import</span> random</div><div class="line"></div><div class="line">queue = []</div><div class="line">MAX_NUM = <span class="number">10</span></div><div class="line">condition = Condition()</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProducerThread</span><span class="params">(Thread)</span>:</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line">		nums = range(<span class="number">5</span>)</div><div class="line">		<span class="keyword">global</span> queue</div><div class="line">		<span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">			condition.acquire()</div><div class="line">			<span class="keyword">if</span> len(queue) == MAX_NUM:</div><div class="line">				<span class="keyword">print</span> <span class="string">"Queue full, producer is waiting"</span></div><div class="line">				condition.wait()</div><div class="line">				<span class="keyword">print</span> <span class="string">"Space in queue, Consumer notified the producer"</span></div><div class="line">			num = random.choice(nums)</div><div class="line">			queue.append(num)</div><div class="line">			<span class="keyword">print</span> <span class="string">"Produced"</span>, len(queue)</div><div class="line">			condition.notify()</div><div class="line">			condition.release()</div><div class="line">			time.sleep(random.random())</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConsumerThread</span><span class="params">(Thread)</span>:</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line">		<span class="keyword">global</span> queue</div><div class="line">		<span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">			condition.acquire()</div><div class="line">			<span class="keyword">if</span> <span class="keyword">not</span> queue:</div><div class="line">				<span class="keyword">print</span> <span class="string">"Nothing in queue, consumer is waiting"</span></div><div class="line">				condition.wait()</div><div class="line">				<span class="keyword">print</span> <span class="string">"Producer added something to queue and notified the consumer"</span></div><div class="line">			num = queue.pop(<span class="number">0</span>)</div><div class="line">			<span class="keyword">print</span> <span class="string">"Consumed"</span>, len(queue)</div><div class="line">			condition.notify()</div><div class="line">			condition.release()</div><div class="line">			time.sleep(random.random())</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">	c_list = []</div><div class="line">	p_list = []</div><div class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</div><div class="line">		p = ProducerThread()</div><div class="line">		p_list.append(p)</div><div class="line">		p.start()</div><div class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</div><div class="line">		c = ConsumerThread()</div><div class="line">		c_list.append(c)</div><div class="line">		c.start()</div></pre></td></tr></table></figure></p>
<h2 id="0x02-基于Queue的实现"><a href="#0x02-基于Queue的实现" class="headerlink" title="0x02 基于Queue的实现"></a>0x02 基于Queue的实现</h2><p>Queue模块内置了Condition，可以使用Queue同时满足互斥和同步两个要求。Queue本来就是线程安全的，而Queue的task_done()方法可以用来同步。Queue的详细使用见<a href="https://docs.python.org/2/library/queue.html" target="_blank" rel="external">官方文档</a>。这个实现代码如下<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment"># -*- coding:utf-8 -*-</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> Queue</div><div class="line"><span class="keyword">import</span> threading</div><div class="line"><span class="keyword">import</span> time</div><div class="line"><span class="keyword">import</span> random</div><div class="line"></div><div class="line">product_queue = Queue.Queue(<span class="number">10</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProducerThread</span><span class="params">(threading.Thread)</span>:</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">		threading.Thread.__init__(self)</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line">		<span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">			product_queue.put(<span class="number">1</span>, block=<span class="keyword">True</span>)</div><div class="line">			time.sleep(random.random())</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConsumerThread</span><span class="params">(threading.Thread)</span>:</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></div><div class="line">		threading.Thread.__init__(self)</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></div><div class="line">		<span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">			product_queue.get(block=<span class="keyword">True</span>)</div><div class="line">			product_queue.task_done()</div><div class="line">			time.sleep(random.random())</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">	c_list = []</div><div class="line">	p_list = []</div><div class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</div><div class="line">		p = ProducerThread()</div><div class="line">		p_list.append(p)</div><div class="line">		p.start()</div><div class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</div><div class="line">		c = ConsumerThread()</div><div class="line">		c_list.append(c)</div><div class="line">		c.start()</div></pre></td></tr></table></figure></p>
<p>Queue也是用Condition来实现的，注意:</p>
<blockquote>
<p>Note: the notify() and notifyAll() methods don’t release the lock; this means that the thread or threads awakened will not return from their wait() call immediately, but only when the thread that called notify() or notifyAll() finally relinquishes ownership of the lock.</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;0x00-背景知识&quot;&gt;&lt;a href=&quot;#0x00-背景知识&quot; class=&quot;headerlink&quot; title=&quot;0x00 背景知识&quot;&gt;&lt;/a&gt;0x00 背景知识&lt;/h2&gt;&lt;p&gt;生产者和消费者是一个常见的问题，它的模型是多个生产者在生产产品，同时多个消费者消费产品，但是仓库容量是有限的，所以当仓库满了生产者需要休眠，而当仓库空了消费者需要唤醒生产者。这里面涉及的问题有互斥和同步。&lt;/p&gt;
&lt;h2 id=&quot;0x01-一种解决方法&quot;&gt;&lt;a href=&quot;#0x01-一种解决方法&quot; class=&quot;headerlink&quot; title=&quot;0x01 一种解决方法&quot;&gt;&lt;/a&gt;0x01 一种解决方法&lt;/h2&gt;&lt;p&gt;可以使用锁来负责互斥，使用threading.Condition来做同步。threading的完整用法见&lt;a href=&quot;https://docs.python.org/2/library/threading.html&quot;&gt;官方文档&lt;/a&gt;，Condition的完整用法见&lt;a href=&quot;https://docs.python.org/2/library/threading.html#condition-objects&quot;&gt;Condition的描述&lt;/a&gt;。简单来说，Condition内置了锁，当调用acquire()方法时，自动上锁，release()释放锁。wait()方法会释放锁后阻塞程序，直到被notify()方法唤醒。Talk is cheap, this is the code.&lt;br&gt;
    
    </summary>
    
      <category term="Python" scheme="http://blog.nudtcat.org/categories/Python/"/>
    
    
      <category term="Python" scheme="http://blog.nudtcat.org/tags/Python/"/>
    
      <category term="操作系统" scheme="http://blog.nudtcat.org/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>珍惜大学仅剩的一年</title>
    <link href="http://blog.nudtcat.org/Chat/%E7%8F%8D%E6%83%9C%E5%A4%A7%E5%AD%A6%E4%BB%85%E5%89%A9%E7%9A%84%E4%B8%80%E5%B9%B4/"/>
    <id>http://blog.nudtcat.org/Chat/珍惜大学仅剩的一年/</id>
    <published>2016-09-23T14:15:59.000Z</published>
    <updated>2016-09-28T03:12:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>珍惜最后一年的大学生活</p>
<ul>
<li>写一篇优秀的毕业论文</li>
<li>在大雨天跑一次步</li>
<li>感受教学楼，图书馆，读几本书</li>
<li>毕业旅行</li>
<li>来一次冒险(骑行||徒步)<a id="more"></a>
</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;珍惜最后一年的大学生活&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;写一篇优秀的毕业论文&lt;/li&gt;
&lt;li&gt;在大雨天跑一次步&lt;/li&gt;
&lt;li&gt;感受教学楼，图书馆，读几本书&lt;/li&gt;
&lt;li&gt;毕业旅行&lt;/li&gt;
&lt;li&gt;来一次冒险(骑行||徒步)
    
    </summary>
    
      <category term="杂谈" scheme="http://blog.nudtcat.org/categories/Chat/"/>
    
    
      <category term="大学生活" scheme="http://blog.nudtcat.org/tags/%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
</feed>
